# python的基础知识
[这个网页介绍python很棒](https://www.liaoxuefeng.com/wiki/1016959663602400)

## python的保留字与运算符的区别

保留字是 Python 语言中一些已经被赋予特定意义的单词，这就要求开发者在开发程序时，不能用这些保留字作为标识符给变量、函数、类、模板以及其他对象命名。
在实际开发中，如果使用 Python 中的保留字作为标识符，则解释器会提示“invalid syntax” 的错误信息  
但是在使用内置函数的时候则不会有这样的问题  
完全可以通过赋值的方式`f = abs` 使f具有取绝对值的功能，但是一般不建议使用内置函数的名字轻易赋值

## 运算符与表达式

### python中的三种除法

    120/100
    >>> 1.2
    120//100
    >>> 1
    120%100
    >>> 20

## 字符串

### 字符串的格式化

```python
# 基本语法是通过 {} 和 : 来代替以前的 %
# 传递参数，把后面的代替{}，和函数传参是一样的
#-------------------------------------------------------------------
#字符串的格式化
'''

^, <, > 分别是居中、左对齐、右对齐，后面带宽度，
: 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。
+ 表示在正数前显示 +，负数前显示 -；
（空格）表示在正数前加空格
b、d、o、x 分别是二进制、十进制、八进制、十六进制。

'''
print('{:.2f}'.format(pi))      #保留小数点后两位数字
print('{:+.2f}'.format(pi))     #带符号保留两位，正数前面显示+
print('{:+.2f}'.format(-pi))    #带符号保留两位，负数前面显示-
print('{:.0f}'.format(pi))      #不带小数
try:
    print('{:0<3d}'.format(pi))
except ValueError:
    print('浮点型需要使用f，整数型要用d')
print('{:0>2d}'.format(5))      #数字补零 (填充左边, 宽度为2)
print('{:x<4d}'.format(5))      #数字补x (填充右边, 宽度为4)
print('{:,}'.format(1000000))   #以逗号分隔的数字格式
print('{:.3e}'.format(1000000)) #指数记法
print('{:.2%}'.format(pi))      #百分号记法
print('{:>10d}'.format(5))     #默认是空格，左对齐
print('{:b}'.format(11))         #转化为二进制
print('{:d}'.format(11))         #十进制
print('{:o}'.format(11))        #八进制
print('{:x}'.format(11))        #十六进制
print('{:#x}'.format(11))
print('{:#X}'.format(11))

'''
3.14
+3.14
-3.14
3
浮点型需要使用f，整数型要用d
05
5xxx
1,000,000
1.000e+06
314.16%
        5
1011
11
13
b
0xb
0XB
'''
```

# 面向对象(Object Oriented Program)
在Python中，所有的数据（包括数字和字符串）实际都是对象，同一类型的对象都有相同的类型。
我们可以使用type()函数来获取关于对象的类型信息。

## 什么是类，什么是对象？
+ 在Python中，使用类来定义同一种类型的对象。
+ 类（class）是广义的数据类型，能够定义复杂数据的特性，包括静态特性（即数据抽象）和动态特性（即行为抽象，也就是对数据的操作方法）。
+ 一个Python类使用变量存储数据域，定义方法来完成动作。
+ 对象是类的一个实例，可以创建一个类的多个对象。
+ 创建类的一个实例的过程被称为实例化。在术语中，对象和实例经常是可以互换的。对象就是实例，而实例就是对象。
+ 类是对象的抽象，而对象是类的具体实例。
+ 类是抽象的，而对象是具体的。
+ 每一个对象都是某一个类的实例。
+ 每一个类在某一时刻都有零或更多的实例。
+ 类是静态的，它们的存在、语义和关系在程序执行前就已经定义好了，对象是动态的，它们在程序执行时可以被创建和删除。
+ 类是生成对象的模板。
语法如下，注意缩进   
**注意析构函数也是方法，是一种特殊的方法**

        class 类名:
            <类属性>
            <定义方法一>  #注意析构函数也是方法，是一种特殊的方法
            
            <定义方法二>

### 什么是类属性

其中类属性是在类中方法之外定义的，类属性属于类，可通过类名访问（尽管也可通过对象访问，但不建议这样做）    
类属性并不在构造函数中  
类属性的修改和增加都是直接通过“类名.属性名”访问。  
这就有点不太好了，类属性可以直接在类外面直接修改

### 类的属性 两种 -> 类属性和实例属性

**类的属性有两种：类属性和实例属性。**
类属性是在类中方法之外定义的  
实例属性是在构造函数`__init__`中定义的，定义时以self为前缀，只能通过对象名访问。

### 数据成员

大致分为两类：  

+ 属于类的数据成员 -> 类属性
是该类所有对象共享的，不属于任何一个对象，在定义类时这类数据成员一般不在任何一个成员方法的定义中。

+ 属于对象的数据成员 -> 实例属性
一般在构造方法__init__()中定义，当然也可以在其他成员方法中定义，在定义和在实例方法中访问数据成员时以self作为前缀，同一个类的不同对象（实例）的数据成员之间互不影响  


在主程序中或类的外部，对象数据成员属于实例(对象)，只能通过对象名访问；而类数据成员属于类，可以通过类名或对象名访问，但是不建议通过对象名访问。



### 什么是构造函数 

一个类中有一个特殊的方法：`__init__`（注意init前后是两个下划线），这个方法被称为构造函数或初始化程序，它是在创建和初始化这个新对象时被调用的。    
**如果用户未设计构造函数，Python将提供一个默认的构造函数。**  
构造函数属于对象，每个对象都有自己的构造函数。  

#### 构造函数的作用

在内存中为类创建一个对象；
调用类的初始化方法来初始化对象。  
在对象被建立之后，self被用来指向对象

### 方法中的函数定义与普通函数的差别

每个方法的第一个参数都是self，self代表将来要创建的对象本身。  
在访问类的实例属性时需要以self为前缀；  
方法只能通过对象来调用（意思是不能通过类来调用，和类属性不一样），即向对象发消息请求对象执行某个方法     
**所以说如果一个对象调用方法后括号内没有参数，意味着在定义此方法的时候只设置了一个参数，那就是self**

### get()方法和set()方法

为了避免客户端直接修改数据的问题，我们提供get()方法返回值，set()方法设置新值。
通常get()方法被称为获取器或访问器，set()方法被称为设置器或修改器。

============================================
我以为这个get()方法或者set()方法是内置方法，本来就有的，可实际上竟然是自己设置的，果然python有了灵活性，就丧失了严格

```python
# _*_ coding:utf-8 _*_

class Rectangle:
    content = "一个矩形"
    def __init__ (self,h,w):
        self.height = h
        self.width = w 
    def getWidth(self):
        return self.width
    def getarea(self):
        return self.height* self.width  
    def getPerimeter(self):  # 如果说我的方法函数不传入参数，为什么会报错呢？
        return ((self.height+self.width)*2)
    def setHeight(self,h):
        if h > 0:
            self.height = h
        else :
            print("不符合要求")
    def setWidth(self,w):
        if w > 0:
            self.width = w
        else: 
            print("不符合要求")

# 访问类属性
print(Rectangle.content)
# >>> 一个矩形
# 访问示例属性

test1 = Rectangle(2,3)
print(test1.width)
# >>> 3
# 获取器或访问器

test1.getarea()
# >>> 6

# 设置器或修改器

test1.setWidth(4)
print(test1.getWidth())
test1.setHeight(-1)
# >>> 不符合要求
```

## 公有属性和私有属性（注意类属性和实例属性的区分）

属性以`__`（两个下划线）开头是私有属性，否则是公有属性。      
私有属性在类外只能通过`对象名._类名__私有成员名`来访问    
不能在类外直接通过 `对象名.属性名` 来访问    

## 私有成员和共有成员

在Python中，以下划线开头的变量名和方法名有特殊的含义，尤其是在类的定义中。  
`_xxx`：受保护成员；  
`__xxx__`：系统定义的特殊成员；  
`__xxx`：私有成员，只有类对象自己能访问，子类对象不能直接访问到这个成员，但在对象外部可以通过`对象名._类名__xxx`这样的特殊方式来访问。  
注意：Python中不存在严格意义上的私有成员  

## 类的方法的分类

### 类的方法有3种：

公有方法  
私有方法  
静态方法  

### 每个对象都有自己的公有方法和私有方法 

一旦创建了对象，公有方法就可以通过对象名调用，调用形式形如`对象名.公有方法(<实参>)`  
私有方法只能在`属于对象的方法中`通过self调用，不能像公有方法一样通过对象名调用。  
`这里有一个值得注意的地方，就是私有属性还可以在类外访问，但是私有方法只能在类的内部调用`
在静态方法中只能访问属于类的成员（也就是类属性），不能访问属于对象的成员（也就是实例属性），而静态方法也只能通过类名调用。  

<!--好傻，明明就是一个东西，为什么偏要起那么多名字-->

## 静态方法

静态方法的定义之前需要添加`@staticmethod`  
静态方法定义时，不需要标识访问对象的self参数，形式上与普通函数的定义类似。    
静态方法只能访问属于类的成员，不能访问属于对象的成员。  
一个对象的所有实例对象共享静态方法。  
使用静态方法时，既可以通过“对象名.静态方法名”来访问，也可以通过“类名.静态方法名”来访问。  

## 类方法

类方法定义之前由`@classmethod`语句引导，第一个形参通常被命名为cls。
类方法既可以通过类名，也可以通过对象名来调用。

## 类方法和静态方法

静态方法和类方法都可以通过类名和对象名调用  
不能直接访问属于对象的成员，只能访问属于类的成员。  
静态方法和类方法不属于任何实例，不会绑定到任何实例，当然也不依赖于任何实例的状态，与实例方法相比能够减少很多开销。  
类方法一般以cls作为类方法的第一个参数表示该类自身，在调用类方法时不需要为该参数传递值，静态方法则可以不接收任何参数。  

### 那话说  类方法和静态方法  的区别是什么呢？ --不知道了

百度到的一个答案，先放在这里：
所谓实例方法就是第一个参数是self，  
所谓类方法就是第一个参数是class，  
而静态方法不需要额外的参数，所以必须区分。

## 类的析构函数

Python中类的析构函数是__del__，用来释放对象占用的资源。    
如果用户未提供析构函数，Python将提供一个默认的析构函数。    
析构函数在对象就要被垃圾回收之前调用，但发生调用的具体时间是不可知的，**所以建议大家尽力避免使用__del__函数。**    

## __name__属性的作用

+ 除了可以在开发环境或命令提示符环境中直接运行，任何Python程序文件都可以作为模块导入并使用其中的对象，这也是实现代码复用的重要形式。
+ 每个Python脚本在运行时都会有一个__name__属性，通过Python程序的__name__属性可以识别程序的使用方式
如果脚本作为模块被导入，则其__name__属性值被设置成模块名
+ 如果脚本作为程序直接运行，则其 __name__属性值被自动设置为字符串“__main__”

## 面向过程编程和面向对象编程

一个例子：假设张三有一笔贷款，年利率为5.75%，贷款年限为30年，贷款金额为35万，计算每月还贷数和总还款数。    

在这里，这笔贷款与张三相关联，我们用一条语句borrower="张三"说明这笔贷款的主贷人是张三，也就是说一笔贷款与某个贷款人相关联，**如果利用面向过程的方法，就是创建不同的变量来存储贷款人的信息**，但这种方法并不理想，因为这些值并不是紧耦合的，最理想的方法是将这些值捆绑在对象中，存储于数据域。


        通俗来讲，  
        紧耦合就是模块或系统之间关系太紧密，
        当发生变化时，某一部分的调整会随着各种紧耦合的关系引起其他部分甚至整个应用程序的更改。

        松耦合就是模块或系统之间仅通过数据接口联系。
        当某个服务的内部结构和实现逐渐发生改变时，
        不影响其他服务。
        大型系统要求系统之间松藕合，
        便于实现功能的任意组合和重用。


+ 基于对象概念来分析问题和设计解题方法就是面向对象编程，它是**将数据和方法一起合并到对象**中。
+ **面向过程方法的重点在设计函数上，面向对象设计的重点在对象和对象的操作上。**

## 类与对象的动态性、混入机制

在Python中比较特殊的是，可以**动态地为自定义类和对象增加或删除成员**，这一点是和很多面向对象程序设计语言不同的，也是Python动态类型特点的一种重要体现。  
Python类型的动态性使得我们可以**动态为自定义类及其对象增加新的属性和行为**，**俗称混入（mixin）机制**，这在大型项目开发中会非常方便和实用。  
例如系统中的所有用户分类非常复杂，不同用户组具有不同的行为和权限，并且可能会经常改变。这时候我们可以独立地定义一些行为，然后根据需要来为不同的用户设置相应的行为能力。  

实现混入机制的语法是：

        import types  #需要导入types模块
        
        # 在类外面定义一个函数，注意参数仍需要self，这个外部定义的函数应该与内部定义的函数一样才行

        对象名.函数名 = types.MethodTypes(函数名,对象名)   # 动态增加一个新的行为
        对象名.函数名()

        del 对象名.函数名  #删除用户行为

## 类的重用方法

类的重用技术通过创建新类来复用已有的代码，而不必从头开始编写，可以使用**系统标准类库**、**开源项目中的类库**、**自定义类等已经调试好的类**，从而降低工作量并减少错误的可能性。  

两种重用方法：类的继承与类的组合。  
+ 类的继承是指在现有类的基础上创建新类，在新类中添加代码，以扩展原有类的属性（数据成员）和方法（成员函数）。
+ 类的组合是指在新创建的类中包含已有类的对象作为其属性。

## 类的继承

继承的出发点在于一些类存在相似点，这些相似点可以被提取出来构成一个基类，基类中的代码通过继承可以在其它类中重用。  
**继承是在一个被作为父类（或称为基类）的基础上扩展新的属性和方法来实现的。**  
父类定义了公共的属性和方法，**继承父类的子类自动具备父类中的非私有属性和非私有方法**，不需要重新定义父类中的非私有内容，并且可以增加新的属性和方法。  

在Python语言中，object类是所有类的最终父类，所有类最顶层的根都是object类。  
在程序中创建一个类时，除非明确指定父类，否则默认从Python的根类object继承。  
Python与C++一样支持多继承。也就是说Python中的一个类可以有多个父类，同时从多个父类中继承所有特性。  

### 语法  

        class ChildClassName(ParentClassName1[,ParentClassName2[,ParentClassName3, …]]):
		#类体或pass语句

子类ChildClassName从圆括号中的父类派生，继承父类的非私有属性和非私有方法。  
如果圆括号中没有内容，则表示从object类派生。  
如果只是给出一个定义，尚没有定义类体时，使用pass语句代替类体。
### 子类调用父类的构造方法：

    有两种方法调用父类的构造方法：
    1. 父类名.__init__(self, 其它参数)  
    2. super(本子类名, self).__init__(其它参数)  #注意，这里的其它参数是指构造方法定义时列出的除self外的参数。

### 父类与子类  ->这名字起的很有意思，子类只能继承这个父类公有的东西，而它所有的子类都继承了父类的特征（属性或方法），和现实非常对应

父类是指被直接或间接继承的类。Python中类object是所有类的直接或间接父类。  
在继承关系中，继承者是被继承者的子类。子类继承所有祖先的非私有属性和非私有方法，子类也可以增加新的属性和方法，子类也可以通过重定义来覆盖从父类继承而来的方法。  

在继承关系中，子类和父类是一种“is-a”的关系，这种关系可以作为判断继承关系的一个基准。  
类Product是一个父类，具备Computer、MobilePhone等类的共同特征。  
Computer、MobilePhone都是类Product的子类，它们共同继承了Product的特征。  

### 子类继承父类的属性

+ 子类继承父类中的非私有属性，但不能继承父类的私有属性。  
+ 子类通过父类中的公有方法访问父类中的私有属性。  
+ 父类与子类如果同时定义了名称相同的属性名称，父类中的属性在子类中将被覆盖

### 子类继承父类的方法

+ 子类继承父类中的非私有方法，不能继承私有方法
+ 当子类中定义了与父类中同名的方法时，子类中的方法将覆盖父类中的同名方法，也就是重写了父类中的同名方法。
+ 如果需要在子类中调用父类中同名的方法，可以采用如下格式：
`super(子类类名, self).方法名称(参数)`

### 继承关系下的构造方法

在Python的继承关系中，如果子类的构造方法没有覆盖父类的构造方法__init__()，则在创建子类对象时，默认执行父类的构造方法。
当子类中的构造方法__init__()覆盖了父类中的构造方法时，创建子类对象时，执行子类中的构造方法，不会自动调用父类中的构造方法。  

子类的构造方法可以调用父类的构造方法。如果需要调用父类的构造方法，必须在子类的构造方法中明确写出调用语句。

## 所谓 一切皆对象 ->object 类是所有类的最终父类

**在Python语言中，object类是所有类的最终父类，所有类最顶层的根都是object类。
在程序中创建一个类时，除非明确指定父类，否则默认从Python的根类object继承。**

所以在定义类的时候，下面是等价的，所有自定义的类都是object类的一个实例，

```python
class Person(object):  # 所有自定义的类其实是来自object类的一个实例
    pass

calss Person:
    pass


```

类定义本身也是个实例（继承自object的为type实例，裸的为classobj实例），因此一个“静态方法”其实只不过是类定义对象的成员罢了……  
c++的static方法则是正儿八经的静态方法，因为类定义本身不是个实例。  
python里，除了极少的几个语句，其余全都是对象实例。一个函数同样是对象实例，因此对python而言其实连方法这一说都不准确…那些个对象方法只不过是指向函数对象的引用，只是属性而已……


# python中的各种下划线

具体参看链接
[python中5种下划线的含义](https://www.runoob.com/w3cnote/python-5-underline.html)    

----------------------------核心风格：避免用下划线作为变量名的开始。---------------

- `单下划线` 开始的成员变量叫做保护变量，意思是只有类对象和子类对象自己能访问到这些变量；  
但这只是一个约定，就像是道德约束，并没有法律效力  
- `双下划线`开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。  

以单下划线开头`_xxx`的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用“from xxx import *”而导入；    
以双下划线开头的`__xxx`代表类的私有属性；在类外面不能直接通过`对象.属性`的方式访问私有属性    
以双下划线开头和结尾的`__xxx__`代表python里特殊方法专用的标识，如 `__init__`代表类的构造函数。  

================================

# 异常（异常是python对象） 和 自定义异常类

Python提供了**异常**和**断言**来处理程序在运行过程中出现的异常和错误  

## 什么是异常？

分清楚程序发生异常和程序执行错误，它们完全是两码事，  
程序由于错误导致的运行异常，是需要程序员想办法解决的；  
但还有一些异常，是程序正常运行的结果，比如用 raise 手动引发的异常。
异常是在程序执行过程中发生的影响程序正常执行的一个事件。  
当Python检测到一个错误时，解释器就会指出当前流已无法继续执行下去，这时候就出现了异常。     
**异常是指因为程序出错而在正常控制流以外采取的行为。 **  
（原来异常的设计是一个有用的东西，有了异常之后程序出错就会终止，而不会出现正常控制流以外采取的行动）

**异常是Python对象**，当Python无法正常处理程序时就会抛出一个异常。    
（看柳青老师ppt中有 `BaseException`是所有异常的基类，而`Exception`是常规错误的基类，所以python中的很多异常都是`BaseException`的派生类）

一旦Python脚本发生异常，程序需要捕获并处理它，否则程序会终止执行。  
异常处理使程序能够处理完异常后继续它的正常执行，不至于使程序因异常导致退出或崩溃。  
**语法错误和逻辑错误不属于异常**,但有些语法错误往往会导致异常，例如由于大小写拼写错误而访问不存在的对象。  

异常分为两个阶段：  
+ 第一个阶段是引起异常发生的错误；  
+ 第二个阶段是检测并处理阶段。  
当程序出现错误，python会自动引发异常，也可以通过raise显式地引发异常。

## python中的标准异常

有很多种，具体可以百度或者上网盘看ppt

## 捕获与处理异常

    try:
    	<可能出现异常的语句块> 
    except <异常类名字name1>：
            <异常处理语句块1>   
        #如果在try部份引发了'name1'异常，执行这部分语句
    except <异常类名字name2>，<数据>:
            <异常处理语句块2>   
        #如果引发了'name2'异常，获得附加的数据
    …
    except:
        <异常处理语句块n>   
        #如果引发了异常，但与上述异常都不匹配，执行此语句块    ### 感觉这一条还是不太熟练
    else:
            <else语句块>
        #如果没有上述所列的异常发生，执行else语句块
    finally:
        <始终执行的语句块>

try/except语句用来检测try语句块中的异常，让except语句捕获异常信息并处理。  
如果不想在异常发生时结束程序，只需要在try里捕获它，并在except中处理捕获到的异常。  
try中的语句块先执行。  
如果try语句块中的某一语句执行时发生异常，Python就跳到except部分，  
从上到下判断抛出的异常对象是否与except后面的异常类相匹配，并执行第一个匹配该异常的except后面的语句块，异常处理完毕。  
如果异常发生了，但是没有找到匹配的异常类别，**则执行不带任何匹配类型的except语句后面的语句块**，异常处理完毕。  

示例代码  
```python
try:
    #正常执行的代码
    pass
except <错误1>:
    #抛出错误1时执行的代码
    pass
except <错误2>:
    #抛出错误2时执行的代码
    pass
except <错误3, 错误4>:
    #抛出错误3或者错误4时执行的代码
    pass
except Exception as result:
    print("未知错误类型：{}".format(result))
else:
    #没有异常才会执行的代码
    pass
finally:
    #无论是否有异常都会执行的代码
    print("程序结束")
```

## 异常的传递

当函数/方法执行出现异常会将异常传递给函数/方法的调用一方
如果传递到主程序，仍然没有异常处理程序才会被终止
注意：
**在开发中，可以在主函数中增加异常捕获，这样在主函数中调用的其他函数，只要出现异常，都会传递到主函数的异常捕获中
这样就不需要在代码中，增加大量的异常捕获能够保证代码的整洁**
示例
```python
def demo1():
    return int(input("请输入一个整数："))
 
 
def demo2():
    return demo1()
 
def main():
    try:
        print(demo2())
    except ValueError:
        print("请输入正确的整数")
    except Exception as result:
        print("未知错误 %s" % result)
 
main()
```

## 自定义异常类

仅仅使用标准模块中的异常类通常不能满足系统开发的需要
有时候需要自定义一些异常类
系统无法识别自定义的异常类，只能在程序中显式地使用raise抛出异常
可以通过扩展BaseException类或其子类来创建自定义异常类
`BaseException`是所有异常的基类

### raise的作用

raise 语句的基本语法格式为：
        
        raise [exceptionName [(reason)]]
其中，用 [] 括起来的为可选参数，其作用是指定抛出的异常名称，以及异常信息的相关描述。如果可选参数全部省略，则 raise 会把当前错误原样抛出；如果仅省略 (reason)，则在抛出异常时，将不附带任何的异常描述信息。   
也就是说，raise 语句有如下三种常用的用法：  
1. raise：单独一个 raise。该语句引发当前上下文中捕获的异常（比如在 except 块中），或默认引发 RuntimeError 异常。  
2. raise 异常类名称：raise 后带一个异常类名称，表示引发执行类型的异常。  
3. raise 异常类名称(描述信息)：在引发指定类型的异常的同时，附带异常的描述信息。  
  
示例如下
```python
>>> raise
Traceback (most recent call last):
  File "<pyshell#1>", line 1, in <module>
    raise
RuntimeError: No active exception to reraise
>>> raise ZeroDivisionError
Traceback (most recent call last):
  File "<pyshell#0>", line 1, in <module>
    raise ZeroDivisionError
ZeroDivisionError
>>> raise ZeroDivisionError("除数不能为零")
Traceback (most recent call last):
  File "<pyshell#2>", line 1, in <module>
    raise ZeroDivisionError("除数不能为零")
ZeroDivisionError: 除数不能为零
```

需要注意的是，就算是直接raise也会触发异常`RuntimeError`

### 理解异常是一个类

通过一个例子来体会

```python
>>> class ShortInputError(Exception):
...     def __init__ (self,length,atleast):
...         Exception.__init__(self)       
...         self.length = length
...         self.atleast = atleast
...
>>> try:
...     s = "123456"
...     if len(s) <10:
...         raise ShortInputError(len(s),10)
... except ShortInputError as result:
...     print("长度至少是{}".format(result.atleast))
... else:
...     print("没有异常")
...
长度至少是10
```

从这个例子很容易看出来，其中ShortInputError是一个派生类，基类是Exception，在这个例子中，如果s的长度小于10，就会抛出ShortInputError，然后异常就会被try捕获，然后通过except匹配，如果匹配上的话，输出带有具体信息的异常


## 断言与上下文管理

断言与上下文管理是两种比较特殊的异常处理方式，在形式上比异常处理结构要简单一些。  
断言是申明表达式为真的判定。如果表达式为假则抛出异常。  
断言语句可以理解为raise-if-not语句，用来测试表示式，如果返回值为假，则触发异常。  
如果断言成功，则程序不采取任何措施，否则触发AssertionError异常。  
断言的语法格式如下：
	assert expression [, arguments]


注意一下三条命令就可以明白`assert`的作用
```python
>>> assert 1+1 ==2
>>> assert 1+1 !=2
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AssertionError
>>> assert 1+1 !=2,"错误"
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AssertionError: 错误
```

使用with自动关闭资源，可以在代码块执行完毕后还原进入该代码块之前的现场或上下文。  
不论何种原因跳出with块，不论是否发生异常，总能保证文件被正确关闭，资源被正确释放。  
常用于文件操作、网络通信之类的场合。  
with语句的语法如下：  
	with context_expr [as var]:
		with块 
